<a name="orzZe"></a>
# 内核概述
<a name="UBOSa"></a>
## 描述
内核是所有 e Cos 中 的关键包之一。它提供了开发多线程应用程序所需的核心功能：

1. 在 系统中创建新线程的能力，无论是在启动期间还是在系统已经运行时。<br />2. 控 制系统中的各种线程，例如操纵它们的优先级。<br />3. 调 度程序的选择，确定当前应该运行哪个线程。<br />4. 一 系列同步原语，允许线程安全地交互和共享数据。<br />5. 集 成系统对中断和异常的支持。<br />在其他一些操作系统中，内核提供了额外的功能。例如，内核还可以提供内存分配功能，设备驱动程序也可以是内核的一部分。这不是 e Cos 的 情况。内存分配由单独的包处理。同样，每个设备驱动程序通常是一个单独的包。使用eCos配置技术对各种包进行组合配置，以满足应用的需求。<br /> eCos 内核包是可选的。可以编写不使⽤任何内核功能的单线程应⽤程序，例如 RedBoot。通常，此类应⽤程序基于中央轮询循环，不断检查所有设 备并在 I/O 发⽣时采取适当的措施。每次迭代都可以进行少量计算，但代价是 I/O 事件发⽣与轮询循环检测到事件之间的延迟增加。当需求很简单 时，使⽤轮询循环开发应⽤程序可能会更容易，避免多线程的复杂性和线程之间的同步。随着需求变得越来越复杂，多线程解决⽅案变得更加合适， 需要使⽤内核。事实上，eCos 中的⼀些更⾼级的包，例如 TCP/IP 堆栈，在内部使⽤多线程。因此，如果应⽤程序使⽤这些包中的任何⼀个，那么内核 将成为必需包，⽽不是可选包。  <br /> 内核功能可以以两种⽅式之⼀使⽤。内核提供了⾃⼰的 C API，具有cyg_thread_create和cyg_mutex_lock 等函数。这些可以直接从应⽤程序 代码或其他包中调⽤。或者，有许多包提供与现有 API 的兼容性，例如 POSIX 线程或 µITRON。这些允许应⽤程序代码调⽤标准函数，例如 pthread_create，这些函数是使⽤ eCos 内核提供的基本功能实现的。在 eCos 应⽤程序中使⽤兼容性包可以更轻松地重⽤在其他环境中开发的 代码以及共享代码。  <br /> 尽管不同的兼容性包对底层内核有相似的要求，例如创建新线程的能力，但在确切的语义上存在差异。例如，严格的 µITRON 合规性要求禁⽤内核 时间⽚。这主要是通过配置技术实现的。内核提供了许多配置选项来控制所提供的确切语义，并且各种兼容性包需要对这些选项进行特定设置。这 有两个重要的后果。⾸先，通常不可能在⼀个 eCos 配置中拥有两个不同的兼容性包，因为它们对底层内核的要求会相互冲突。其次，内核⾃⼰的 API 的语义只是松散地定义，因为有许多配置选项。为了 ⽰例cyg_mutex_lock将始终尝试锁定互斥体，但各种配置选项决定了互斥体已被锁定并且可能发⽣优先级反转时的行为。  <br /> 内核包的可选特性给其他代码带来了⼀些复杂性，尤其是设备驱动程序。⽆论内核是否存在，设备驱动程序都应该尽可能地⼯作。然⽽，系统的某些 部分，特别是与中断处理相关的部分，在包含 eCos 内核的多线程环境和没有内核的单线程环境中应该以不同的⽅式实现。为了应对这两种情况，通 ⽤ HAL 包提供了驱动程序 API，具有cyg_drv_interrupt_attach 等功能。当内核包存在时，这些驱动 API 函数直接映射到等效的内核函数，例如 cyg_interrupt_attach，使⽤宏来避免任何开销。当内核不存在时，通⽤ HAL 包直接实现驱动程序 API，但这种实现⽐内核中的更简单，因为它可 以假设单线程环境。  

<a name="kNLf1"></a>
##  调度器  
 当系统涉及多个线程时，需要⼀个调度程序来确定当前应该运行哪个线程。 eCos 内核可以配置两个调度器之⼀，位图调度器和多级队列（MLQ） 调度器。位图调度器效率更⾼⼀些，但有许多限制。⼤多数系统将改为使⽤ MLQ 调度程序。将来可能会添加其他调度程序，作为内核包的扩展或在 单独的包中。  <br /> 位图和 MLQ 调度程序都使⽤简单的数字优先级来确定应该运行哪个线程。优先级的数量可通过选项CYGNUM_KERNEL_SCHED_PRIORITIES 进行配置，但典型的系统最多有 32 个优先级。因此线程优先级将在 0 到 31 的范围内，0 是最⾼优先级，31 是最低优先级。通常只有系统的空闲线 程会以最低优先级运行。线程优先级是绝对的，因此如果当前所有⾼优先级线程都被阻塞，内核将只运行⼀个低优先级线程。  <br /> 位图调度器每个优先级只允许⼀个线程，所以如果系统配置了 32 个优先级，那么它被限制为只有 32 个线程 。 对于许多应⽤程序来说仍然⾜够 了。可以使⽤⼀个简单的位图来跟踪当前可运行的线程。位图还可⽤于跟踪等待互斥锁或其他同步原语的线程。识别最⾼优先级的可运行或等待线 程涉及对位图的简单操作，然后可以使⽤数组索引操作来获取线程数据结构本⾝。这使得位图调度程序快速且完全确定。  <br /> MLQ 调度程序允许多个线程以相同的优先级运行。这意味着除了可⽤内存量之外，系统中的线程数没有限制。但是，诸如查找最⾼优先级的可运行 线程之类的操作⽐位图调度程序要昂贵⼀些。  <br /> 可选地，MLQ 调度程序⽀持时间⽚，当发⽣⼀定数量的时钟滴答时，调度程序会⾃动从⼀个可运行线程切换到另⼀个。只有当有两个具有相同优先 级的可运行线程且没有更⾼优先级的可运行线程时，时间⽚才会发挥作⽤。如果时间⽚被禁⽤，那么⼀个线程将不会被另⼀个具有相同优先级的线 程抢占，并且将继续运行，直到它显式地让出处理器或直到它被阻塞，例如，等待同步原语。配置选项CYGSEM_KERNEL_SCHED_TIMESLICE和 CYGNUM_KERNEL_SCHED_TIMESLICE_TICKS控制时间⽚。位图调度程序不提供时间⽚⽀持。每个优先级只允许⼀个线程，因此不可能抢占当 前线程以⽀持具有相同优先级的另⼀个线程。  

<a name="CrRDt"></a>
##  同步原语  
 eCos 内核提供了许多不同的同步原语：互斥锁、条件变量、计数信号量、邮箱和事件标志。  <br /> 互斥锁的⽤途与其他原语⾮常不同。互斥锁允许多个线程安全地共享资源：线程锁定互斥锁，操作共享资源，然后再次解锁互斥锁。其他原语⽤于 在线程之间传递信息，或者从与中断处理程序关联的 DSR 到线程。<br /> 当锁定互斥锁的线程需要等待某个条件变为真时，它应该使⽤条件变量。条件变量本质上只是⼀个线程等待的地⽅，另⼀个线程或 DSR 可以使⽤ 它来唤醒它。当线程等待条件变量时，它会在等待之前释放互斥锁，当它唤醒时，它会在继续之前重新获取它。这些操作是原⼦的，因此不能引⼊同 步竞争条件。    <br /> 计数信号量⽤于指⽰特定事件已发⽣。消费者线程可以等待此事件发⽣，⽣产者线程或 DSR 可以发布该事件。有⼀个与信号量相关的计数，因此 如果事件快速连续多次发⽣，此信息不会丢失，并且适当数量的信号量等待操作将成功。  <br /> 邮箱还⽤于指⽰发⽣了特定事件，并允许每个事件交换⼀项数据。通常，该数据项是指向某个数据结构的指针。由于需要存储这些额外的数据，邮 箱的容量是有限的。如果⽣产者线程⽣成邮箱事件的速度快于它们被消费的速度，那么为了避免溢出，它将被阻塞，直到邮箱中的空间再次可⽤。这 意味着 DSR 通常不能使⽤邮箱来唤醒线程。相反，邮箱通常只在线程之间使⽤。  <br /> 事件标志可⽤于等待⼀些不同的事件，并表⽰这些事件中的⼀个或⼏个已经发⽣。这是通过将位掩码中的位与不同事件相关联来实现的。与计数 信号量不同，不会尝试跟踪已发⽣事件的数量，仅跟踪事件⾄少发⽣⼀次的事实。与邮箱不同，它不可能随事件⼀起发送附加数据，但这确实意味 着没有溢出的可能性，因此事件标志可以在 DSR 和线程之间以及线程之间使⽤。  <br /> eCos 通⽤ HAL 包提供了⾃⼰的设备驱动 API，其中包含⼀些上述同步原语。这些允许中断处理程序的 DSR 向更⾼级别的代码发送事件信号。 如果配置包括 eCos 内核包，那么驱动 API 例程直接映射到等效的内核例程，允许中断处理程序与线程交互。如果不包含内核包并且应⽤程序仅 包含以轮询模式运行的单个线程，则驱动程序 API 完全在通⽤ HAL 中实现，⽆需担⼼多个线程，实现显然会更简单。  

<a name="Dg90z"></a>
##  线程和中断处理  
 在正常操作期间，处理器将运行系统中的线程之⼀。这可能是应⽤程序线程、在 TCP/IP 堆栈内部运行的系统线程或空闲线程。有时会发⽣硬件中 断，导致控制权被短暂地转移到中断处理程序。当中断完成时，系统的调度程序将决定是将控制权返回给被中断的线程还是其他⼀些可运行的线 程 。<br /> 线程和中断处理程序必须能够交互。如果线程正在等待某个 I/O 操作完成，则与该 I/O 关联的中断处理程序必须能够通知线程该操作已完成。这 可以通过多种⽅式实现。⼀种⾮常简单的⽅法是让中断处理程序设置⼀个 volatile 变量。然后，⼀个线程可以连续轮询，直到设置此标志，可能在 其间休眠⼀个时钟滴答。连续轮询意味着 cpu 时间不可⽤于其他活动，这对于某些但不是所有应⽤程序可能是可以接受的。每个时钟滴答轮询⼀ 次会⼤⼤减少开销，但这意味着线程可能直到整个时钟滴答结束后才检测到 I/O 事件已发⽣。在典型系统中，这可能⻓达 10 毫秒。对于某些应⽤ 程序来说，这样的延迟可能是可以接受的，但不是全部。  <br /> 更好的解决⽅案是使⽤同步原语之⼀。中断处理程序可以向条件变量发出信号，发送到信号量，或使⽤其他原语之⼀。该线程将对同⼀原语执行等 待操作。在 I/O 事件发⽣之前，它不会消耗任何 cpu 周期，并且当事件确实发⽣时，线程可以⽴即再次开始运行（受任何可能也可运行的更⾼优先 级线程的限制）。  <br /> 同步原语构成共享数据，因此必须注意避免并发访问问题。如果被中断的线程只是在执行⼀些计算，那么中断处理程序可以⾮常安全地操作同步 原语。但是，如果被中断的线程恰好在某个内核调⽤中，那么某些内核数据结构很可能会被破坏。  <br /> 避免此类问题的⼀种⽅法是内核函数在执行任何关键区域时禁⽤中断。在⼤多数架构上，这将很容易实现并且速度⾮常快，但这意味着中断会经 常被禁⽤并且会持续很⻓时间。对于⼀些可能⽆关紧要的应⽤程序，但许多嵌⼊式应⽤程序要求中断处理程序在硬件中断发⽣后尽快运行。如果 内核依赖于禁⽤中断，那么它将⽆法⽀持此类应⽤程序。  <br /> 相反，内核使⽤两级⽅法来处理中断。与每个中断向量相关联的是⼀个中断服务程序或 ISR，它将尽可能快地运行，以便为硬件提供服务。  <br /> 然⽽，ISR 只能进行少量内核调⽤，主要与中断⼦系统相关，并且它不能进行任何会导致线程唤醒的调⽤。如果 ISR 检测到 I/O 操作已完成，因此应 该唤醒线程，它会导致相关的延迟服务例程或 DSR 运行。允许 DSR 进行更多内核调⽤，例如它可以发出条件变量信号或发送到信号量。  <br /> 禁⽤中断会阻⽌ ISR 运行，但系统中很少有部分会禁⽤中断，⽽且只会在短时间内禁⽤。线程禁⽤中断的主要原因是操纵与 ISR 共享的某些状态。 例如，如果⼀个线程需要将另⼀个缓冲区添加到空闲缓冲区的链接列表中，并且 ISR 可能随时从该列表中删除⼀个缓冲区，则该线程将需要为操 作该列表所需的⼏条指令禁⽤中断。如果此时硬件引发中断，它会保持挂起状态，直到重新启⽤中断。  <br /> 类似于禁⽤或启⽤中断，内核有⼀个调度程序锁。 cyg_mutex_lock和cyg_semaphore_post等各种内核函数会要求调度器锁，操作内核数据 结构，然后释放调度器锁。如果中断导致请求 DSR 并且调度程序当前被锁定，则 DSR 保持挂起状态。当调度程序锁被释放时，任何挂起的 DSR 都 会运行。  <br /> 这些可能会将事件发布到同步原语，从⽽导致其他更⾼优先级的线程被唤醒。  <br /> 例如，考虑以下场景。系统有⼀个⾼优先级线程A，负责处理⼀些来⾃外部设备的数据。当数据可⽤时，该设备将引发中断。  <br /> 还有另外两个线程 B 和 C，它们花时间执行计算并偶尔将结果写⼊某种显⽰。此显⽰是共享资源，因此使⽤互斥锁来控制访问。  <br /> 在特定时刻，线程 A 可能会被阻塞，等待信号量或另⼀个同步原语，直到数据可⽤。线程 B 可能正在运行执行⼀些计算，⽽线程 C 可以运行等待 其下⼀个时间⽚。启⽤中断，并且调度程序被解锁，因为没有线程处于内核操作的中间。此时设备引发中断。硬件将控制权转移到 eCos 提供的低级 中断处理程序，该处理程序会准确计算出发⽣了哪个中断，然后运行相应的 ISR。该 ISR 适当地操作硬件，确定现在有可⽤的数据，并希望通过发布 到信号量来唤醒线程 A。然⽽，ISR 不允许直接调⽤cyg_semaphore_post ，因此 ISR 请求其关联的 DSR 运行并返回。没有更多的中断需要处 理，因此内核接下来会检查 DSR。⼀个 DSR 处于挂起状态，并且调度程序当前已解锁，因此 DSR 可以⽴即运行并发布信号量。  <br /> 这将具有使线程 A 再次可运行的效果，因此调度程序的数据结构会相应调整。当 DSR 返回时，线程 B 不再是最⾼优先级的可运行线程，因此它将 被挂起，取⽽代之的是线程 A 获得对 cpu 的控制权。  <br /> 在上⾯的例⼦中，在中断发⽣的那⼀刻没有内核数据结构被操作。然⽽，这不能假设。假设线程 B 已经完成了它当前的⼀组计算并且想要将结果写 ⼊显⽰器。它将要求适当的互斥锁并操纵显⽰。  <br /> 现在假设线程 B 被时间分⽚以⽀持线程 C，并且线程 C 也完成了计算并希望将结果写⼊显⽰器。它将调⽤cyg_mutex_lock。此内核调⽤锁定调 度程序，检查互斥锁的当前状态，发现互斥锁已被另⼀个线程拥有，挂起当前线程，并将控制权切换到另⼀个可运行线程。另⼀个中断发⽣在这个 cyg_mutex_lock调⽤的中间，导致 ISR ⽴即运行。 ISR 决定应该唤醒线程 A，因此它请求运行其 DSR 并返回给内核。此时有⼀个挂起的 DSR， 但调度程序仍被对 cyg_mutex_lock 的调⽤锁定，因此DSR ⽆法⽴即运行。相反，对cyg_mutex_lock的调⽤被允许继续，这在某些时候涉及解 锁调度程序。挂起的 DSR 现在可以运行，安全地发布信号量，从⽽唤醒线程 A。  <br /> 如果 ISR 直接调⽤cyg_semaphore_post⽽不是将其留给 DSR，那么内核数据结构很可能会出现某种损坏。例如，内核可能完全失去了对其中⼀ 个线程的跟踪，并且该线程将永远不会再次运行。中断处理的两级⽅法，ISR 和 DSR，⽆需禁⽤中断即可防⽌此类问题。  

<a name="seeT7"></a>
##  调⽤上下⽂  
 eCos 定义了许多上下⽂。每个上下⽂中只允许某些调⽤，例如，线程上的⼤多数操作或同步原语都不允许从 ISR 上下⽂中调⽤。不同的上下⽂是 初始化、线程、ISR 和 DSR。  <br /> eCos 启动时会经历多个阶段，包括设置硬件和调⽤ C++ 静态构造函数。在此期间，中断被禁⽤并且调度程序被锁定。当配置包含内核包时，最终操 作是调⽤cyg_scheduler_start。此时启⽤中断，解锁调度程序，并将控制权转移到最⾼优先级的可运行线程。如果配置还包括 C 库包，那么通常 C 库启动包将创建⼀个线程，该线程将调⽤应⽤程序的主⼊⼝点。  <br /> ⼀些应⽤程序代码也可以在调度程序启动之前运行，并且这些代码在初始化上下⽂中运行。  <br /> 如果应⽤程序部分或完全⽤ C++ 编写，则将运行任何静态对象的构造函数。  <br /> 或者，应⽤程序代码可以定义⼀个函数cyg_user_start ，该函数在任何 C++ 静态构造函数之后被调⽤。这允许应⽤程序完全⽤ C 编写。  
```c
cyg_user_start(void)
{
    /* 在此处执行特定于应⽤程序的初始化 */
}
```
 应⽤程序没有必要提供cyg_user_start函数，因为系统将提供⼀个什么都不做的默认实现  。<br /> 从静态构造函数或cyg_user_start内部执行的典型操作包括创建线程、同步原语、设置警报和注册特定于应⽤程序的中断处理程序。  <br /> 事实上，对于许多应⽤程序⽽⾔，所有此类创建操作都在此时发⽣，使⽤静态分配的数据，避免了对动态内存分配或其他开销的任何需求。  <br /> 在初始化上下⽂中运行的代码在禁⽤中断和锁定调度程序的情况下运行。不允许重新启⽤中断或解锁调度程序，因为此时不能保证系统处于完全 ⼀致的状态。结果是初始化代码不能使⽤诸如cyg_semaphore_wait 之类的同步原语来等待外部事件。允许锁定和解锁互斥体：没有其他线程 在运行，因此可以保证互斥体尚未锁定，因此锁定操作永远不会阻塞；这在进行可能在内部使⽤互斥锁的库调⽤时很有⽤。  <br /> 在启动序列结束时，系统将调⽤cyg_scheduler_start并且各种线程将开始运行。在线程上下⽂中，⼏乎所有内核函数都可⽤。取决于⽬标硬件，中 断相关操作可能会有⼀些限制。例如，硬件可能要求在控制返回线程上下⽂之前在 ISR 或 DSR 中确认中断，在这种情况下，线程不应调⽤ cyg_interrupt_acknowledge 。  <br /> 在任何时候，处理器都可能收到⼀个外部中断，导致控制权从当前线程转移。通常，由 eCos 提供的 VSR 将运行并准确确定发⽣了哪个中断。然后 VSR 将切换到适当的 ISR，它可以由 HAL 包、设备驱动程序或应⽤程序提供。在此期间，系统在 ISR 上下⽂中运行，并且不允许⼤多数内核函数调 ⽤。这包括各种同步原语，例如，不允许 ISR 发布到信号量以指⽰事件已发⽣。通常应该从 ISR 内部执行的唯⼀操作是与中断⼦系统本⾝相关的操 作，例如屏蔽中断或确认已处理中断。在 SMP 系统上，也可以使⽤ ISR 上下⽂中的⾃旋锁。  <br /> 当 ISR 返回时，它可以请求在安全的情况下⽴即运行相应的 DSR，这将在 DSR 上下⽂中运行。此上下⽂也⽤于运行警报功能，线程可以通过锁定 调度程序临时切换到 DSR 上下⽂。只有某些内核函数可以从 DSR 上下⽂中调⽤，尽管⽐在 ISR 上下⽂中调⽤更多。特别是可以使⽤任何不能阻 塞的同步原语。  <br /> 这些包括cyg_semaphore_post、 cyg_cond_signal、 cyg_cond_broadcast、 cyg_flag_setbits和cyg_mbox_tryput。不能 使⽤任何可能阻塞的原语，例如cyg_semaphore_wait、 cyg_mutex_lock或cyg_mbox_put。从 DSR 内部调⽤此类函数可能会 导致系统挂起。  <br /> 各种内核函数的特定⽂档提供了有关有效上下⽂的更多详细信息。  

<a name="zAJZ2"></a>
##  错误处理和断⾔  
 在许多 API 中，每个函数都需要对其参数以及系统的当前状态进行⼀些验证。这应该确保正确使⽤每个函数，并且应⽤程序代码不会尝试对互斥 体或类似的东西执行信号量操作。如果检测到错误，则返回合适的错误代码，例如 POSIX 函数pthread_mutex_lock可以返回各种  错误代码包括EINVAL和EDEADLK。这种⽅法存在许多问题，尤其是在深度嵌⼊式系统的上下⽂中：  <br /> 1. 在互斥锁和所有其他函数中执行这些检查需要额外的 cpu 周期并显着增加代码⼤⼩。即使应⽤程序编写正确并且仅在正确的条件下使⽤合 理的参数进行系统函数调⽤，这些开销仍然存在。<br /> 2. 返回错误代码只有在调⽤代码检测到这些错误代码并采取适当措施时才有⽤。实际上，调⽤代码通常会忽略任何错误，因为程序员“知道”该 函数正在正确使⽤。如果程序员弄错了，则可能会检测到并报告错误情况，但应⽤程序仍会继续运行，并且可能会在⼀段时间后神秘地失败  <br /> 3. 如果调⽤代码总是检查错误代码，那会增加更多的 CPU 周期和代码⼤⼩开销。  <br /> 4. 通常没有办法从某些错误中恢复，所以如果应⽤程序代码检测到诸如EINVAL之类的错误，那么它所能做的就是以某种⽅式中⽌应⽤程序。  

 在 eCos 内核中采⽤的⽅法是不同的。 cyg_mutex_lock等函数不会返回错误代码。相反，它们包含各种可以启⽤或禁⽤的断⾔。在开发过程中， 断⾔通常保持启⽤状态，各种内核函数将执行参数检查和其他系统⼀致性检查。如果检测到问题，则将报告断⾔失败并终⽌应⽤程序。在典型的调 试会话中，将安装⼀个合适的断点，开发⼈员现在可以检查系统的状态并准确计算出正在发⽣的事情。在开发周期快结束时，将通过操纵 eCos 基 础设施包中的配置选项来禁⽤断⾔，并且所有断⾔将在编译时被消除。假设此时应⽤程序代码已⼤部分调试：代码的初始版本可能已尝试对互斥 体执行信号量操作，但类似的问题将在⼀段时间前得到修复。    <br /> 这种⽅法有很多优点：  <br /> 1. 在最终的应⽤程序中不会有检查参数和其他条件的开销。所有这些代码都将在编译时被删除。  <br /> 2. 由于最终的应⽤程序不会承受任何开销，因此系统在开发过程中做更多的⼯作是合理的。特别是各种断⾔可以测试更多的错误条件和更复杂 的错误。当检测到错误时，可以提供描述错误的⽂本消息，⽽不仅仅是返回错误代码。  <br />3、应用程序员无需处理各种内核函数调用返回的错误码。这简化了应用程序代码。<br /> 4. 如果检测到错误，则⽴即报告断⾔失败并暂停应⽤程序。由于应⽤程序代码没有检查错误代码，因此不可能忽略错误条件。  

 尽管没有⼀个内核函数返回错误代码，但其中许多确实返回了状态条件。例如，函数cyg_semaphore_timed_wait⼀直等待，直到⼀个事件被发 送到⼀个信号量，或者直到发⽣了⼀定数量的时钟滴答声。通常调⽤代码需要知道等待操作是否成功或是否发⽣超时。 cyg_semaphore_timed_wait返回⼀个布尔值：返回值为零或假表⽰超时，⾮零返回值表⽰等待成功。  <br /> 在传统 API 中，⼀种常⻅的错误情况是内存不⾜。例如，POSIX 函数pthread_create通常必须为线程堆栈和其他每个线程数据动态分配⼀些内 存。如果⽬标硬件没有⾜够的内存来满⾜所有需求，或者更常⻅的是应⽤程序包含内存泄漏，那么可能没有⾜够的内存可⽤，函数调⽤将失败。 eCos 内核通过从不执行任何动态内存分配来避免此类问题。相反，应⽤程序代码负责提供内核数据结构所需的所有内存和   其他需求。在cyg_thread_create的情况下，这意味着⼀个 cyg_thread 数据结构来保存线程详细信息，以及⼀个⽤于线程堆栈的 char 数组。  <br /> 在许多应⽤程序中，这种⽅法导致所有数据结构都是静态分配的，⽽不是动态分配的。这有⼏个优点。如果应⽤程序实际上对于⽬标硬件的内存来 说太⼤了，那么在链接时⽽不是在运行时就会出现错误，从⽽使问题更容易诊断。静态分配不涉及与动态分配相关的任何常⻅开销，例如不需要跟 踪系统中的各种空闲块，并且可以完全消除系统中的malloc 。如果所有数据都是静态分配的，就不会出现碎⽚和内存泄漏等问题。然⽽，⼀些应⽤ 程序⾮常复杂，需要动态分配内存，并且各种内核函数不区分静态和动态分配的内存。调⽤代码仍然有责任确保有⾜够的内存可⽤，并且将空指针 传递给内核将导致断⾔或系统故障。  

<a name="a45rK"></a>
#  SMP ⽀持  
 ⽀持对称多处理系统  
<a name="fCCV0"></a>
##  描述  
 eCos 包含对有限对称多处理 (SMP) 的⽀持。这仅在选定的架构和平台上可⽤。该实现对⽀持的硬件类型有许多限制。  
<a name="NxIJl"></a>
##  系统启动  
 SMP 系统上的系统启动顺序需要有所不同，尽管这在很⼤程度上对应⽤程序代码是透明的。主启动仅在⼀个 CPU 上进行，称为主 CPU。所有其他 CPU，即辅助 CPU，要么在重置时处于挂起状态，要么被 HAL 捕获并在它们启动时进⼊⾃旋状态。主 CPU 负责复制 DATA 段并将 BSS 归零（如果需要）、调⽤ HAL 变体和平台初始化例程以及调⽤构造函数。然后它调⽤cyg_start进⼊应⽤程序。然后 应⽤程序可以创建额外的线程和其他对象。  <br /> 只有当应⽤程序调⽤cyg_scheduler_start时，辅助 CPU 才会被初始化。该例程扫描可⽤的辅助 CPU 列表并调⽤HAL_SMP_CPU_START 来启动每个 CPU。最后它调⽤⼀个内部函数Cyg_Scheduler::start_cpu进⼊主 CPU 的调度程序。  <br /> 每个辅助 CPU 在 HAL 中启动，它在cyg_kernel_cpu_startup 调⽤内核之前完成所有每个 CPU 的初始化。这里它要求调度程序锁并 调⽤Cyg_Scheduler::start_cpu。  <br /> Cyg_Scheduler::start_cpu对主 CPU 和辅助 CPU 都是通⽤的。这段代码做的第⼀件事是为这个 CPU 的 CPU 间中断安装⼀个中断 对象。从这⼀点开始，代码与单 CPU 情况相同：选择并输⼊⼀个初始线程。  <br /> 从这⼀点开始，CPU 都是平等的，eCos 不再区分主 CPU 和辅助 CPU。然⽽，就中断传递⽽⾔，硬件仍然可以区分它们。  
<a name="s0Lyp"></a>
##  调度  
 为了正常运行，操作系统内核必须保护其重要的数据结构（例如运行队列）免受并发访问。在单 CPU 系统中，唯⼀需要担⼼的并发活动 是异步中断。内核可以通过禁⽤中断轻松保护其数据结构免受这些影响。然⽽，在多 CPU 系统中，这是不够的，因为它不会阻⽌其他 CPU 的访问。  <br /> eCos 内核使⽤调度程序锁来保护其重要的数据结构。在单 CPU 系统中，这是⼀个简单的计数器，它以原⼦⽅式递增以获取锁，并以递减 ⽅式释放它。如果锁被减为零，则可以调⽤调度程序来选择不同的线程来运行。因为在请求调度程序锁时可能会继续服务中断，所以不允 许 ISR 访问内核数据结构，或调⽤可以访问的内核例程。相反，当数据结构处于⼀致状态时，所有此类操作都推迟到在锁定释放操作期间 运行的关联 DSR 例程。  <br /> 通过选择不依赖中断操作来保护数据结构的内核锁定机制，将 eCos 转换为 SMP ⽐其他情况更容易。使 eCos SMP 安全所需 的主要更改是将调度程序锁转换为可嵌套的⾃旋锁。这是通过将⾃旋锁和 CPU id 添加到原始计数器来完成的。  <br /> 获取调度器锁的算法⾮常简单。如果调度程序锁的 CPU id 与当前 CPU 匹配，那么它可以增加计数器并继续。如果不匹配，CPU 必须在⾃旋锁上⾃旋，之后它可以递增计数器并将⾃⼰的⾝份存储在 CPU id 中。  <br /> 为了释放锁，计数器递减。如果它变为零，则必须将 CPU id 值设置为 NONE 并清除⾃旋锁。  <br /> 为了保护这些序列免受中断，必须在禁⽤中断的情况下执行它们。然⽽，由于这些是⾮常短的代码序列，它们不会对中断延迟产⽣ 不利影响。  <br /> 除了转换调度程序锁之外，进⼀步为 SMP 准备内核是⼀件相对较⼩的事情。主要变化是将各种标量管家变量转换为由 CPU id 索引的数组。其中包括当前线程指针、need_reschedule 标志和时间⽚计数器。  <br /> ⽬前只有多级队列 (MLQ) 调度器能够⽀持 SMP 配置。对该调度程序所做的主要更改是为了应对同时执行多个线程的问题。  <br /> 正在运行的线程标有它们正在执行的 CPU。调度线程时，调度程序会跳过所有正在运行的线程，直到找到⼀个挂起的线程。虽然 不是恒定时间算法，如在单 CPU 情况下，但这仍然是确定性的，因为最坏情况下的时间受系统中 CPU 数量的限制。  <br /> 调度程序的第⼆个更改是⽤于决定何时调⽤调度程序以选择新线程的代码。调度程序试图让 n 个 CPU 运行 n 个最⾼优先级的 线程。由于⼀个 CPU 上的事件或中断可能需要在另⼀个 CPU 上重新调度，因此必须有⼀种机制来决定这⼀点。  <br /> ⽬前实现的算法⾮常简单。给定⼀个刚刚被唤醒的线程（或改变了它的优先级），调度程序扫描 CPU，从它当前运行的那个开 始，寻找优先级低于新线程的当前线程。如果找到⼀个，则将重新调度中断发送到该 CPU 并继续扫描，但现在使⽤重新调度 CPU 的当前线程作为候选线程。通过这种⽅式，新线程可以尽可能快地运行，希望在当前 CPU 上运行，并且由于处理重新调度中断，剩 余的 CPU 将选择剩余的最⾼优先级线程。  <br /> 调度程序的最终更改是处理时间⽚。尽管所有 CPU 都必须处理时间⽚，但只有⼀个 CPU 接收定时器中断。为了完成这项⼯作， 接收定时器中断的 CPU 会递减所有 CPU 的时间⽚计数器，⽽不仅仅是它⾃⼰的。如果 CPU 的计数器达到零，则它会向该 CPU 发送时间⽚中断。在接收到中断后，⽬标 CPU 进⼊调度程序并寻找另⼀个具有相同优先级的线程来运行。这⽐将时钟滴答分配 给所有 CPU 更有效，因为只有在时间⽚发⽣时才需要中断。  <br /> 所有现有的同步机制都像以前⼀样在 SMP 系统中⼯作。添加了额外的同步机制，以⾃旋锁的形式为 SMP 提供显式同步。  
<a name="tWusB"></a>
##  SMP 中断处理  
 系统的 SMP 特性需要特别注意的主要领域是设备驱动程序，尤其是中断处理。设备驱动程序的 ISR、DSR 和线程组件很有可能 在不同的 CPU 上执行。由于这个原因，⽀持 SMP 的设备驱动程序正确使⽤与中断相关的功能更为重要。通常，设备驱动程序会 使⽤驱动程序 API ⽽不是直接调⽤内核，但任何⼈都不太可能尝试在没有内核包的情况下使⽤多处理器系统。  <br /> 内核 API 中添加了两个新函数来执行中断路由： cyg_interrupt_set_cpu和cyg_interrupt_get_cpu。虽然⽬前不⽀持，但 cpu 参 数的特殊值将来可能会⽤于指⽰中断是动态路由的还是 CPU 本地的。⼀旦⼀个向量被路由到⼀个新的 CPU，所有其他的中断屏蔽和 配置操作都与那个 CPU 相关，如果相关的话。  

<a name="TQwLA"></a>
#  线程创建  
 cyg_thread_create    创建⼀个新线程  
<a name="jA7mR"></a>
##  概要  
```c
#include <cyg/kernel/kapi.h>
void cyg_thread_create(cyg_addrword_t sched_info, cyg_thread_entry_t* entry,
cyg_addrword_t entry_data, char* name, void* stack_base, cyg_ucount32 stack_size,
cyg_handle_t* handle, cyg_thread* thread);

```
<a name="rD5HC"></a>
##   描述  
 cyg_thread_create函数允许应⽤程序代码和 eCos 包创建新线程。在许多应⽤程序中，这只发⽣在系统初始化期间，所有需要的数据都 是静态分配的。但是，如有必要，可以随时创建其他线程。新创建的线程始终处于挂起状态，并且在通过调⽤cyg_thread_resume恢复它之 前不会开始运行。此外，如果线程是在系统初始化期间创建的，那么在启动 eCos 调度程序之前它们不会开始运行。  <br /> name参数主要⽤于调试⽬的，从⽽更容易跟踪哪个 cyg_thread 结构与哪个应⽤程序级线程相关联。内核配置选项 CYGVAR_KERNEL_THREADS_NAME控制是否实际使⽤此名称。 <br /> 在创建时，每个线程都被分配了⼀个唯⼀的句柄，这将存储在句柄参数指向的位置。此线程上的后续操作（包括所需的cyg_thread_resume） 应使⽤此句柄来标识线程。  <br /> 内核需要为每个线程提供少量空间，以 cyg_thread 数据结构的形式保存该线程的当前状态等信息。为了避免在内核中需要动态内存分配， 这个空间必须由更⾼级别的代码提供，通常以静态变量的形式。线程参数提供了这个空间。  
<a name="zUJLR"></a>
##  线程⼊⼝点  
 线程的⼊⼝点采⽤以下形式：  
```c
void thread_entry_function(cyg_addrword_t data)
{
    ...
}
```
 	 cyg_thread_create的第⼆个参数是指向此类函数的指针。第三个参数entry_data⽤于将附加数据传递给函 数。通常，这采⽤指向某些静 态数据的指针或⼩整数的形式，如果线程不需要任何附加数据，则为0 。<br /> 	如果cyg_thread_create函数有返回值，那么这等效于调⽤cyg_thread_exit 的线程。即使线程不再运行，它仍会在调度程序中注册。如果应⽤程序需要重新使 ⽤ cyg_thread 数据结构，那么⾸先需要调⽤cyg_thread_delete 。    
<a name="biXMR"></a>
##  线程优先级  
sched_info 参数为调度程序提供附加信息。确切的细节取决于正在使用的调度程序。对于位图和 mlqueue 调度程序，它是一个小整数，通常在 0 到 31 的范围内，其中 0 是最高优先级。最低优先级通常仅由系统的空闲线程使用。优先级的确切数量由内核配置选项 CYGNUM_KERNEL_SCHED_PRIORITIES 控制。应用程序开发人员有责任了解系统中的各种线程，包括由 eCos 包创建的线程，并确保所有线程在合适的优先级。对于其他包创建的线程，这些包提供的文档应说明任何要求。<br /> cyg_thread_set_priority  
