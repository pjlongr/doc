# 与内存相关的经典bug

## 返回指向局部变量的指针

```cpp
int* func(){
    int a = 2;
    return &a;
}
void main(){
    int *p =func();
    *p = 20;
}
```
局部变量a位于func函数的栈帧中，当func函数执行结束，其栈帧也不存在，因此main函数调用func函数后得到的指针指向一个不存在的变量。

## 错误的理解指针运算

```cpp
int sun(int *arr,int len){
    int sum = 0;
    for(int i=0;i <len;i++)
    {
        sum += *arr;
        arr+=sizeof(int);
    }
    return sum;
}
```
指针运算中的加1并不是说移动1字节而是移动1单位，指针指向数据类型的大小就是1单位。

## 解引用有问题的指针

```cpp
int a;
scanf("%d",&a);
```
上述代码中局部变量a的值是不确定的。如果a的值被解释成指针后指向代码区或者其他不可写区域，那么操作系统将立刻kill进程。如果a的值被解释成指针后指向的栈区，这时其他函数的栈帧被破坏掉了，无法定位bug。如果a的值被解释成指针后指向的堆区或数据区，程序动态分配的内存被破坏掉，无法定位bug。

## 读取未被初始化的内存

```cpp
void add(){
    int *a = (int*)malloc(sizeof(int));
    *a+= 10;
}
```
如果malloc自己维护的内存够用，那么malloc从空闲的内存中找到一个返回。该内存可能包含之前的信息，此时不一定为0。

## 引用已被释放的内存

```cpp
void add(){
    int *a = (int*)malloc(sizeof(int));
    free(a);
    int b = *a;
}
```
上述代码引用了被释放的内存块。如果指针a指向的那个内存块释放后没有被malloc再次分配出去，此时指针a指向的值跟之前是一样的。指针a指向的那个内存块已经被malloc分配出去了，指针a指向的内存可能已经被覆盖了，对a解引用得到的就是一个被覆盖的数据，程序的行为是不可预测的，难以定位，可能要等程序运行很久才会被发现。

## 数组下标是从0开始

```cpp
void init（int n）{
    int *arr = (int*)malloc(n*sizeof(int));
    for(int i =0;i<n;i++)
    {
        arr[i] = i;
    }
}
```
数组访问越界，可能破坏malloc的工作状态。

## 栈溢出

```cpp
void buffer_overflow(){
    char buf[32];
    gets(buf);
    return ;
}
```
上述代码假设用户输入不超过32自己，一旦超过就将立刻破坏栈帧中相邻的数据，破坏函数栈帧最好的结果是程序立刻崩溃，否则要运行很长一段时才出现错误，或者程序不会异常，但计算结果是错误的。

## 内存泄漏

```cpp
void memory_leak(){
    int *p = (int *)malloc(sizeof(int));
    return ;
}
```
申请内存直接返回，没有释放，程序会不断的申请内存，但不去释放，这会导致进程的堆区越来越大直到进程被操作系统终止。

## 落点的

（1）了解到这些，在编辑代码的时候可以知道哪些会引起程序会造成不可预测的结果，在编辑阶段可以规避造成程序死机。
 （2）程序死机的时候，可以通过分析对照上述的问题，快速定位、排除问题。